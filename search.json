[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures SoSe 25 Notes",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "python/iterables.html",
    "href": "python/iterables.html",
    "title": "1¬† Iterables",
    "section": "",
    "text": "for Loops and Comprehensions\nfor loops in Python are used to iterate over any iterable (like lists, tuples, strings, sets, dictionaries, generators, etc.).\nSyntax:",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  },
  {
    "objectID": "python/iterables.html#for-loops-and-comprehensions",
    "href": "python/iterables.html#for-loops-and-comprehensions",
    "title": "1¬† Iterables",
    "section": "",
    "text": "for item in iterable:\n    # do something with item\n\nCommon Use Cases & Idioms:\n\nBasic Iteration\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nfor name in names:\n    print(name)\n\n\nIterating with Index (use enumerate)\nfor i, name in enumerate(names):\n    print(f\"{i}: {name}\")\n\n\nIterating Multiple Sequences (use zip)\nages = [25, 30, 22]\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old\")\n\n\nIterating Over Dictionaries\nperson = {\"name\": \"Alice\", \"age\": 25}\nfor key, value in person.items():\n    print(key, value)\n\n\nNested Loops\nfor i in range(3):\n    for j in range(2):\n        print(i, j)\n\n\n\nWhat Are Comprehensions?\nComprehensions are concise expressions for generating new iterables (like lists, sets, or dicts) using the syntax of a for loop inside a single line.\n\nTypes and Idiomatic Patterns\n\nList Comprehension (most common)\nsquares = [x**2 for x in range(5)]\n# Output: [0, 1, 4, 9, 16]\n\n\nConditional List Comprehension\nevens = [x for x in range(10) if x % 2 == 0]\n# Output: [0, 2, 4, 6, 8]\n\n\nSet Comprehension\nunique_lengths = {len(word) for word in [\"a\", \"ab\", \"abc\", \"ab\"]}\n# Output: {1, 2, 3}\n\n\nÔ∏è Dict Comprehension\nwords = [\"apple\", \"banana\", \"cherry\"]\nlengths = {word: len(word) for word in words}\n# Output: {'apple': 5, 'banana': 6, 'cherry': 6}\n\n\nNested Comprehensions (2D lists)\nmatrix = [[i * j for j in range(3)] for i in range(3)]\n# Output: [[0, 0, 0], [0, 1, 2], [0, 2, 4]]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  },
  {
    "objectID": "python/iterables.html#enumerate",
    "href": "python/iterables.html#enumerate",
    "title": "1¬† Iterables",
    "section": "enumerate()",
    "text": "enumerate()\nenumerate() is a built-in Python function that adds a counter to any iterable (like a list, tuple, or string), returning an enumerate object, which yields (index, value) pairs on iteration.\n\nType:\ntype(enumerate(['a', 'b', 'c']))  # &lt;class 'enumerate'&gt;\nLike zip, it‚Äôs a lazy iterable, meaning it produces values on demand and can be turned into a list or looped over.\n\n\nBasic Example:\nfruits = ['apple', 'banana', 'cherry']\n\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)\nOutput:\n0 apple\n1 banana\n2 cherry\n\n\nCommon & Idiomatic Use Cases for enumerate()\n\nAvoid Manual Indexing with range(len(...))\n\nInstead of:\nfor i in range(len(fruits)):\n    print(i, fruits[i])\nDo this:\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)\nCleaner, more Pythonic.\n\nStart Index at a Custom Value\n\nfor i, fruit in enumerate(fruits, start=1):\n    print(f\"{i}. {fruit}\")\nOutput:\n1. apple\n2. banana\n3. cherry\nGreat for user-friendly numbering (e.g.¬†starting from 1 instead of 0).\n\nTracking Position in File or Data\n\nwith open(\"file.txt\") as f:\n    for lineno, line in enumerate(f, start=1):\n        print(f\"Line {lineno}: {line.strip()}\")\nCommon in data processing and log parsing.\n\nEnumerate with Conditional Logic\n\ncolors = ['red', 'blue', 'green', 'blue']\nfor i, color in enumerate(colors):\n    if color == 'blue':\n        print(f\"'blue' found at index {i}\")\nHelps track positions that meet a condition.\n\nUse with zip() for Triple Iteration\n\na = ['x', 'y', 'z']\nb = [10, 20, 30]\nfor i, (x, y) in enumerate(zip(a, b)):\n    print(f\"{i}: {x}-{y}\")\nCombines enumeration with parallel iteration.\n\n\nüîö Summary:\n\n\n\n\n\n\n\n\nFunction\nWhat it does\nOutput form\n\n\n\n\nzip(a, b)\nCombines sequences\n(a[i], b[i])\n\n\nenumerate(x)\nAdds index to an iterable\n(i, x[i])\n\n\nenumerate(x, start=n)\nLike above, but starts at n\n(n, x[0]), (n+1, x[1]), ‚Ä¶",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  },
  {
    "objectID": "python/iterables.html#zip",
    "href": "python/iterables.html#zip",
    "title": "1¬† Iterables",
    "section": "zip()",
    "text": "zip()\nThe built-in zip() function takes two or more iterables (like lists, tuples, or strings) and aggregates elements from each iterable by position (i.e.¬†index). It returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the input iterables.\nzip(iterable1, iterable2, ...)\nIt stops when the shortest input iterable is exhausted.\nYou can think of zip() as:\nzip(A, B, C) ‚áí [(A[0], B[0], C[0]), (A[1], B[1], C[1]), ...]\nNo matter the input shape, zip() always does the same thing: Group elements by position across multiple iterables.\nzip() returns a zip object, which is an iterator. You need to explicitly convert it into a list or tuple to see the full output:\nlist(zip(...))     # common\ntuple(zip(...))    # possible\n\nCommon Use Cases and Idiomatic Patterns\n\nCombining Lists (Zipping)\n\nletters = ['a', 'b', 'c']\nnumbers = [1, 2, 3]\n\nzipped = list(zip(letters, numbers))\nprint(zipped)\n# Output: [('a', 1), ('b', 2), ('c', 3)]\nUseful for:\n\nPairing related data.\nIterating in parallel over multiple lists.\n\n\nLooping Over Zipped Values\n\nnames = ['Alice', 'Bob']\nscores = [85, 92]\n\nfor name, score in zip(names, scores):\n    print(f\"{name} scored {score}\")\n# Output:\n# Alice scored 85\n# Bob scored 92\nThis is an idiomatic way to loop over multiple sequences in sync.\n\nUnzipping (Inverse of zip) with * Unpacking\n\npairs = [('a', 1), ('b', 2), ('c', 3)]\n\nletters, numbers = zip(*pairs)\n\nprint(letters)  # Output: ('a', 'b', 'c')\nprint(numbers)  # Output: (1, 2, 3)\nExplanation:\n\n*pairs unpacks the list into separate arguments: zip(('a', 1), ('b', 2), ...)\nzip() groups by position: first elements, second elements, etc.\n\nThis is effectively transposing a 2D structure.\n\nCreating Dictionaries\n\nkeys = ['name', 'age']\nvalues = ['Alice', 30]\n\ndictionary = dict(zip(keys, values))\nprint(dictionary)\n# Output: {'name': 'Alice', 'age': 30}\nA common idiom when you have two separate sequences representing keys and values.\n\nZipping with Unequal Lengths\n\na = [1, 2, 3]\nb = ['x', 'y']\n\nprint(list(zip(a, b)))\n# Output: [(1, 'x'), (2, 'y')]\nOnly pairs up to the shortest iterable. (See itertools.zip_longest() if you want padding.)\n\n\nUnified Understanding: Zip vs.¬†‚ÄúUnzip‚Äù\nWhy zip() seems to do two very different things:\n\nZipping: Combine separate lists into paired tuples.\nUnzipping: Split paired tuples into separate lists.\n\nclarification:\n# Zipping\nlist1 = ['a', 'b', 'c']\nlist2 = [1, 2, 3]\nzipped = list(zip(list1, list2))\n# Output: [('a', 1), ('b', 2), ('c', 3)]\n\n# Unzipping\npairs = [('a', 1), ('b', 2), ('c', 3)]\nunzipped = list(zip(*pairs))\n# Output: [('a', 'b', 'c'), (1, 2, 3)]\nEven though the intent differs, the operation is identical:\n\nGroup elements by position across the given iterables.\n\n\nIn zipping, the elements come from separate sequences.\nIn unzipping, the unpacking * turns a list of tuples into separate positional iterables, and zip groups those.\n\nSo:\n\nzip(A, B) zips rows.\nzip(*rows) transposes the matrix ‚Äî an ‚Äúunzip‚Äù operation in spirit, but still just zip applied to unpacked input.\n\n\n\nBonus: Visual Matrix Analogy\nConsider this ‚Äútable‚Äù of rows (a list of tuples):\nrows = [('a', 1),\n        ('b', 2),\n        ('c', 3)]\nIf you do:\nzip(*rows)\nYou‚Äôre transposing it into:\n[('a', 'b', 'c'), (1, 2, 3)]\nThis is column-wise grouping.\n\n\nSummary\n\nzip() is a fundamental tool for working with multiple iterables in parallel.\nAlways groups by index.\nUse it to zip, loop, unzip, transpose, and build dictionaries.\nWhen used with *, you can reverse its effect by unpacking rows into inputs.\n\nIt‚Äôs simple, powerful, and highly idiomatic in Python.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  },
  {
    "objectID": "python/iterables.html#map-and-filter",
    "href": "python/iterables.html#map-and-filter",
    "title": "1¬† Iterables",
    "section": "map() and filter()",
    "text": "map() and filter()\n\nWhat is map()?\nmap(func, iterable) applies the function func to each item in the iterable, returning a map object (an iterator).\n\n\nBasic Use:\nnums = [1, 2, 3, 4]\nsquared = list(map(lambda x: x**2, nums))\n# Output: [1, 4, 9, 16]\n\n\nWhat is filter()?\nfilter(func, iterable) selects items from the iterable for which func(item) is true, returning a filter object (an iterator).\nnums = [1, 2, 3, 4]\nevens = list(filter(lambda x: x % 2 == 0, nums))\n# Output: [2, 4]\n\n\nIdiomatic Use Cases:\n\nApply Transformation to All Elements\nuppercased = list(map(str.upper, [\"a\", \"b\", \"c\"]))\n# Output: ['A', 'B', 'C']\n\n\nFilter with Condition\nshort_words = list(filter(lambda w: len(w) &lt; 4, [\"a\", \"apple\", \"bat\", \"cat\"]))\n# Output: ['a', 'bat', 'cat']\n\n\nCombine with zip\na = [1, 2, 3]\nb = [4, 5, 6]\nsummed = list(map(lambda x: x[0] + x[1], zip(a, b)))\n# Output: [5, 7, 9]\n\n\nEquivalent List Comprehensions (more Pythonic)\n# Instead of map\n[x**2 for x in nums]\n\n# Instead of filter\n[x for x in nums if x % 2 == 0]\nNote: While map and filter are perfectly valid, list comprehensions are often preferred in Python due to better readability.\nFinal Recap Table\n\n\n\n\n\n\n\n\nConcept\nDescription\nCommon Use Cases\n\n\n\n\nfor loop\nIterates over any iterable\nBasic iteration, nested loops\n\n\nComprehension\nConcise iterable construction\nList/set/dict creation, filtering\n\n\nmap(func, it)\nApply func to all items\nTransform elements\n\n\nfilter(func, it)\nKeep items where func(item) is True\nSelective filtering",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  },
  {
    "objectID": "python/iterables.html#extended-unpacking-in-python-with-and",
    "href": "python/iterables.html#extended-unpacking-in-python-with-and",
    "title": "1¬† Iterables",
    "section": "Extended Unpacking in Python with * and **",
    "text": "Extended Unpacking in Python with * and **\nPython allows powerful unpacking syntax to distribute or collect values in assignments and function calls.\n\nSequence Unpacking (with *)\nStandard unpacking:\na, b, c = [1, 2, 3]\nprint(a, b, c)\nOutput:\n1 2 3\nExtended unpacking:\na, *b = [1, 2, 3, 4]\nprint(a, b)\nOutput:\n1 [2, 3, 4]\n*a, b = [1, 2, 3, 4]\nprint(a, b)\nOutput:\n[1, 2, 3] 4\na, *b, c = [1, 2, 3, 4, 5]\nprint(a, b, c)\nOutput:\n1 [2, 3, 4] 5\n\n\nUnpacking in Function Calls (with * and **)\n\nPositional unpacking with *:\ndef add(a, b, c):\n    return a + b + c\n\nnums = [1, 2, 3]\nprint(add(*nums))\nOutput:\n6\n\n\nKeyword unpacking with **:\ndef greet(name, greeting):\n    return f\"{greeting}, {name}!\"\n\ndata = {'name': 'Alice', 'greeting': 'Hello'}\nprint(greet(**data))\nOutput:\nHello, Alice!\n\n\n\nFunction Definitions with *args and **kwargs\ndef show_args(*args):\n    print(args)\n\nshow_args(1, 2, 3)\nOutput:\n(1, 2, 3)\ndef show_kwargs(**kwargs):\n    print(kwargs)\n\nshow_kwargs(a=1, b=2)\nOutput:\n{'a': 1, 'b': 2}\n\n\n\nMixing Both *args and **kwargs\ndef demo(a, b, *args, **kwargs):\n    print(f\"a = {a}\")\n    print(f\"b = {b}\")\n    print(f\"args = {args}\")\n    print(f\"kwargs = {kwargs}\")\n\npos = [1, 2, 3, 4]\nkw = {'x': 10, 'y': 20}\ndemo(*pos, **kw)\nOutput:\na = 1\nb = 2\nargs = (3, 4)\nkwargs = {'x': 10, 'y': 20}\n\n\nComparing Similar Function Calls\ndef mixed(a, *rest):\n    print(f\"a = {a}\")\n    print(f\"rest = {rest}\")\n\nl = [1, 2, 3]\na = 0\nmixed(a, *l)\nOutput:\na = 0\nrest = (1, 2, 3)\nmixed(a, l)\nOutput:\na = 0\nrest = ([1, 2, 3],)\n\n\nSummary Table\n\n\n\n\n\n\n\n\n\nContext\nSyntax\nWhat it Does\nExample\n\n\n\n\nAssignment\n*var\ncollects excess items into a list\na, *b = [1,2,3] ‚Üí b=[2,3]\n\n\nFunction call\n*seq\nunpacks iterable into positional arguments\nf(*[1,2]) ‚Üí f(1,2)\n\n\nFunction call\n**dict\nunpacks dictionary into keyword arguments\nf(**{'x':1}) ‚Üí f(x=1)\n\n\nFunction definition\n*args\ncollects extra positional arguments as tuple\ndef f(*args)\n\n\nFunction definition\n**kwargs\ncollects extra keyword arguments as dictionary\ndef f(**kwargs)",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Iterables</span>"
    ]
  }
]